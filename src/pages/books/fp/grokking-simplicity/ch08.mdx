---
layout: '@features/ui/layouts/post-layout.astro'
title: '계층형 설계'
description: '[쏙쏙 들어오는 함수형 코딩 Ch8-9]'
updatedAt: '2023-01-06T13:07:45.343Z'
tags: 'develop, fp, immutability'
---

import { DEFAULT_CUSTOM_COMPONENTS } from '@features/mdx';
export const components = DEFAULT_CUSTOM_COMPONENTS;

## 계층형 설계 <code>_stratified design_</code>

소프트웨어를 계층으로 구성하는 기술. 각 계층에 있는 함수는 바로 아래 계층의 함수를 이용해 정의

- 장바구니 기능
  - 비즈니스 규칙, 특정 서비스만의 규칙: `getFreeShipping()`, `cartTax()`
  - 장바구니를 위한 동작, 도메인 영역에서 공통적으로 적용되는 규칙: `removeItemByName()`, `calcTotal()`, `addItem()`, `setPriceByName()`
  - copy-on-write: `removeItems()`, `addElementLast()`
  - 언어에서 지원하는 기능: `array.slice()`

각 계층을 정확히 구분하기는 어렵지만, 계층을 잘 구분하려면 구분하기 위한 다양한 변수를 찾고, 찾은 것을 가지고 어떻게 해야하는지 알아야 한다

## 계층형 설계 감각 키우기

### 입력

#### 함수 본문

- 길이
- 복잡성
- 구체화 단계
- 함수 호출
- 프로그래밍 언어의 기능 사용

#### 계층 구조

- 화살표 길이
- 응집도
- 구체화 단계

#### 함수 시그니처

- 함수명
- 인자 이름
- 인자 값
- 리턴 값

### 출력

#### 조직화

- 새로운 함수를 어디에 놓을지 결정
- 함수를 다른 곳으로 이동

#### 구현

- 구현 바꾸기
- 함수 추출하기
- 데이터 구조 바꾸기

#### 변경

- 새 코드를 작성할 곳 선택하기
- 적절한 수준의 구체화 단계 결정하기

## 계층형 설계 패턴

### 패턴 1: 직접 구현

- **한 단계 구체화 수준에 관한 문제만 해결**
  - 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절한 구체화 수준에서 해결해야 한다
  - 너무 구체적이라면 코드에서 나는 냄새임
- 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 빼내기
  - 일반적인 함수가 많을수록 재사용성이 높아짐

### 패턴 2: 추상화 벽

- 중요한 세부 구현을 감추고 인터페이스를 제공
- 인터페이스를 활용하면 고차원으로 생각할 수 있고,
- 고수준의 추상화 단계만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있음

### 패턴 3: 작은 인터페이스

- 시스템이 커질수록 비즈니스 개념을 나타내는 중요한 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다

### 패턴 4: 편리한 계층

- 그냥 좋아서 계층을 추가하면 안된다
- 코드와 그 추상화 계층은 작업할 때 편리해야 하고, 비즈니스 문제를 잘 풀 수 있어야 함

### ex. 넥타이 하나를 사면 무료로 넥타이 클립을 하나 주는 코드

#### 유지보수 하기 어려운 코드

```javascript
function freeTieClip(cart) {
  let hasTie = false;
  let hasTieClip = false;
  for (let i = 0; i < cart.length; i++) {
    const item = cart[i];
    if (item.name === 'tie') hasTie = true;
    if (item.name === 'tie clip') hasTieClip = true;
  }

  if (hasTie && !hasTieClip) {
    const tieClip = makeItem('tie clip', 0);
    return addItem(cart, tieClip);
  }

  return cart;
}
```

- '직접 구현' 패턴을 따르지 않았기 때문
  - 마케팅 캠페인에 관련된 함수가 장바구니가 배열이라는 사실을 알 필요가 없다
  - 장바구니 배열을 돌다가 off-by-one 에러가 생기면 실패할 수 있다

#### 코드 개선하기

직접 구현 패턴 적용하기

##### 저수준 코드 추출하기

- 장바구니 안에 제품이 있는지 확인하는 함수가 있다면, 저수준 반복문을 직접 쓰지 않아도 됨

##### 호출 그래프를 만들어 함수 호출 시각화하기

- 함수에서 사용하는 다른 함수, 언어 기능을 호출 그래프로 시각화
- 해당 함수/기능들의 추상화 수준이 같은지 확인
  - **한 함수에서 서로 다른 추상화 단계를 사용하면 코드가 명확하지 않아 읽기 어렵다**
  - 다른 함수: `makeItem`, `addItem`
  - 언어 기능: array index, `for` loop
- 저수준 코드를 함수로 분리
  - `isInCart`
- 개선된 함수 `freeTieClip`에서는 장바구니가 배열인지 몰라도 됨 => 내부에서 사용하는 함수들이 모두 비슷한 계층에 있다는 것
- 모든 함수가 그래프에 있어야 하고, 화살표는 옆이나 위가 아닌 아래로 향해야 함

<a href="https://ibb.co/80RGJ9B">
  <img
    src="https://i.ibb.co/56zCdL9/Screenshot-2023-01-06-at-9-35-54-PM.png"
    alt="Screenshot-2023-01-06-at-9-35-54-PM"
    border="0"
  />
</a>

- **한 함수의 모든 화살표는 같은 길이를 가져야 한다**
  - 화살표가 복잡한 이유는 코드가 정돈되어 있지 않기 때문
  - 한 함수에서 여러 계층을 사용하지 않도록 정리해야 함
  - 경우에 따라 개선을 하더라도 화살표 길이가 여전히 동일하지 않을 수 있지만, 화살표 수를 줄이거나 길이가 좀더 줄어든다면 괜찮다
